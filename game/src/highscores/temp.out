package highscores
{

import ShipSpec;
import Utility;
import GlamourShot;
import Assets;
import Screen;

import flash.display.*;
import flash.geom.*;
import flash.text.*;
import flash.events.Event;

public class HighScoresPanel extends Sprite
  {
  private static const scoreDescriptY : int = 25;
  private static const scoreAmountY : int = 29;
  private static const scoreCenter : int = 140;
  private static const pleaseEnterY : int = 80;
  private static const initialsY : int = 110;
  private static const initialsX : int = 55;
  private static const initialsWidth : int = 110;
  private static const infoY : int = 160;
  
  public var shipSpec : ShipSpec;
  public var scoreListing : ScoreListing;
  public var done : Boolean;
  public var highScore : Boolean;
  
  public function get initials() : String { return initialsText.text; }
  public function set initials(value:String) : void
    {
    initialsText.text = value;
    initialsText.setTextFormat(initialsFormat);
    }
  
  public function get infoText() : String { return infoTextField.text; }
  public function set infoText(value:String) : void
    {
    infoTextField.text = value;
    infoTextField.setTextFormat(infoTextFormat);
    }
  
  private var infoTextField : TextField; // displays whether you win/lose/are done
  private var pleaseEnterText : TextField; // displays the "Please enter your name:" text
  private var scoreDescriptText : TextField;
  private var scoreAmountText : TextField;
  private var initialsText : TextField;
  //private var letterFields : Array;
  private var startTime : Number;
  private var infoTextFormat : TextFormat; // displays whether you win/lose/are done
  private var pleaseEnterFormat : TextFormat; // displays the "Please enter your name:" text
  private var scoreDescriptFormat : TextFormat; // Career Earnings: \n Team Total:
  private var initialsFormat : TextFormat;
  private var numberFormat : TextFormat; // ends up to the right of Career Earnings: \n Team Total:
  private var cursor : String = " ";
  private var cursorPositive : String = "_";
  
  private static const winText : String = "Congratulations!\nYou have a high score!";
  private static const loseText : String = "Your score did not make it\n into the high scores board.";
  private static const doneText : String = "Done!";
  
  public function HighScoresPanel( _shipSpec : ShipSpec, _scoreListing : ScoreListing, _highScore : Boolean )
    {
    var i : int;
    
    pleaseEnterFormat = new TextFormat();
    pleaseEnterFormat.font = "text";
    pleaseEnterFormat.align = "center";
    pleaseEnterFormat.size = 14;
    pleaseEnterFormat.color = 0xffffff;
    pleaseEnterFormat.bold = false;
    
    scoreDescriptFormat = new TextFormat();
    scoreDescriptFormat.font = "text";
    scoreDescriptFormat.align = "right";
    scoreDescriptFormat.size = 16;
    scoreDescriptFormat.color = 0xffffff;
    scoreDescriptFormat.bold = false;
    
    infoTextFormat = new TextFormat();
    infoTextFormat.font = "text";
    infoTextFormat.align = "center";
    infoTextFormat.size = 14;
    infoTextFormat.color = 0xffffff;
    infoTextFormat.bold = true;
    
    initialsFormat = new TextFormat();
    initialsFormat.font = "text";
    initialsFormat.align = "left";
    initialsFormat.size = 14;
    initialsFormat.color = 0xffffff;
    initialsFormat.bold = true;
    
    numberFormat = new TextFormat();
    numberFormat.font = "number";
    numberFormat.align = "left";
    numberFormat.size = 14;
    numberFormat.color = 0xffffff;
    numberFormat.bold = true;
    numberFormat.leading = 4;
    
    initialsText = new TextField();
    initialsText.x = initialsX;
    initialsText.y = initialsY;
    initialsText.width = initialsWidth;
    
    var date : Date = new Date();
    //var tf : TextField;
    startTime = date.getTime();
    initials = "";
    shipSpec = _shipSpec;
    scoreListing = _scoreListing;
    highScore = _highScore;
    
    initialsText.setTextFormat(initialsFormat);
    
    // this is a bit of extra complication -- 
    //  If the glamourshot is used directly with an alpha value that isn't 1,
    //  it will have all of it's parts set to that value and THEN rendered.
    //  That's bad, it means you can see parts of the ship through other parts
    //  of the ship.  
    //  The workaround is to first render the thing opaque, and draw it to a bitmap.  
    //  Then, the bitmap is drawn to the screen with an alpha value.  
    //  This causes the ship as a whole to be rendered with alpha, not just it's parts.  
    var gs : GlamourShot = new GlamourShot( shipSpec, 1 );
    gs.x = gs.width / 2;
    gs.y = gs.height / 2 - 10;
    var sprite : Sprite = new Sprite();
    sprite.addChild( gs );
    var bmpd : BitmapData = new BitmapData(gs.width,gs.height,true,0);
    bmpd.draw( sprite );
    var bmp : Bitmap = new Bitmap( bmpd );
    bmp.alpha = 0.5;
    addChild( bmp );
    
    // The colored box for this panel.
    switch (shipSpec.teamCode)
      {
      case ShipSpec.RED_TEAM:    bmp = new Assets.topBoxRed;    break;
      case ShipSpec.BLUE_TEAM:   bmp = new Assets.topBoxBlue;   break;
      case ShipSpec.GREEN_TEAM:  bmp = new Assets.topBoxGreen;  break;
      case ShipSpec.YELLOW_TEAM: bmp = new Assets.topBoxYellow; break;
      }
    addChild( bmp );
    
    // Handle text.  
    var textToShow : String;
    if ( highScore )
      textToShow = winText;
    else
      textToShow = loseText;
    
    scoreDescriptText = placeText(0,scoreDescriptY,"Career Earnings: \nTeam Score: ",
                                  scoreDescriptFormat,scoreCenter,this);
    scoreAmountText = placeText(scoreCenter,scoreAmountY,""+shipSpec.careerEarnings+"\n"+scoreListing.score,
                                numberFormat,200-scoreCenter,this);
    
    // This works, but the code makes no sense.
    // How does the getter/setter above play into this? -> I've not a clue.  
    if ( highScore )
      {
      initialsText = placeText(initialsX,initialsY,initials,initialsFormat,initialsWidth,this);
      pleaseEnterText = placeText(0,pleaseEnterY,"Please enter your name:",pleaseEnterFormat,200,this);
      }
    
    infoTextField = placeText(0,infoY,textToShow,infoTextFormat,200,this);
    }
  
  private function placeText( x : int, y : int, text : String, 
                              format : TextFormat = null, width : int = -1, 
                              sprite : Sprite = null ) : TextField
    {
    var tf : TextField = new TextField();
    tf.embedFonts = true;
    tf.x = x;
    tf.y = y;
    if ( width >= 0 )
      tf.width = width;
    tf.text = text;
    if ( format != null )
      tf.setTextFormat( format );
    if ( sprite == null )
      sprite = Screen.foreground;
    sprite.addChild( tf );
    return tf;
    }
  
  public function enterSelection( selection : String ) : void
    {
    switch( selection )
      {
      case "DONE": m_donePress(); return;
      case "CLR": initials = cursor; return;
      case "DEL": deletePress(); return;
      case "SPC": if ( !done ) selection = " "; break;
      default: break;
      }
      
    if ( done )
      return;
    
    if ( initials.length < 9 )
      initials = initials.slice( 0, initials.length - 1 ) + selection + cursor;
    }
  
  public function onSelectionChange( newSelection : String ) : void
    {
    // don't do anything.  This function was left incase it becomes useful - the hooks will still be here.
    /*if ( done )
      {
      cursorPositive = " ";
      return;
      }
    
    switch( newSelection )
      {
      case "DONE":
      case "CLR":
      case "DEL": 
      case "SPC":
        cursorPositive = "a";
        return;
      default: break;
      }
    
    cursorPositive = newSelection.toLowerCase();
    */
    }
  
  // This function traps any players trying to change the CPU's name.  
  public function donePress() : void
    {
    if ( !shipSpec.isCPUControlled )
      m_donePress();
    }
  
  // The REAL done press function.  
  private function m_donePress() : void
    {
    if ( done )
      {
      done = false;
      if ( highScore )
        infoText = winText;
      else
        infoText = loseText;
      }
    else
      {
      done = true;
      infoText = doneText;
      }
    
    // still need to change the graphics
    }
  
  public function deletePress() : void
    {
    if ( shipSpec.isCPUControlled )
      return; // Robots never make mistakes.  
    
    if ( done )
      return;
    
    initials = initials.slice( 0, initials.length - 2 ) + cursor;
    }
  
  // this should be called from HighScores.as
  public function update() : void
    {
    var i : int;
    
    // update the cursor
    var date : Date = new Date();
    var time : Number = date.getTime();
    var timeDelta : Number = time - startTime;
    var lastCursor : String = cursor;
    cursor = " ";
    if ( timeDelta % 1000 < 500 )
      cursor = cursorPositive;
    
    if ( cursor != lastCursor )
      initials = initials.slice( 0, initials.length - 1 ) + cursor;
    } // onEnterFrame
  }

}package highscores
{

public class ScoreListing
  {
  public var score : int;
  public var teamSize : int; // values 1-4.  0 is invalid (a zero person team).
  public var initials : String; // comma delimited if multiple people
  public var playerIDs : Array; // an array of player IDs, each ID being a player on the team
                                //   this is not persistant, it is only used in HighScoresEntryScreen
  
  public function ScoreListing()
    {
    score = -1;
    initials = "";
    teamSize = 0;
    playerIDs = null;
    }
  }

}// An AI for entering high scores in the high scores entry screen.  
package highscores
{

import flash.utils.Timer;
import flash.events.TimerEvent;
import flash.events.Event;

import highscores.HighScoresMovementTimer;
import highscores.HighScoresPanel;

public class HighScoresAI extends Timer
  {
  public var expired : Boolean;
  
  private var name : String;
  private var playerID : uint;
  private var x : int;
  private var y : int;
  private var xPress : Function;
  private var yPress : Function;
  private var board : Array; // a reference to the letter pool
  private var panel : HighScoresPanel;
  
  public function get initials() : String { return panel.initials; }
  
  // He will start entering his name as soon as he is constructed.  
  public function HighScoresAI( _name:String, _playerID:uint, _x:int, _y:int, _board:Array, _panel:HighScoresPanel,
                                _xPress:Function, _yPress:Function )
    {
    name = _name;
    playerID = _playerID;
    x = _x;
    y = _y;
    board = _board;
    panel = _panel;
    xPress = _xPress;
    yPress = _yPress;
    
    panel.enterSelection("CLR");
    
    super(HighScoresMovementTimer.movementDelay);
    addEventListener(TimerEvent.TIMER, think);
    
    this.start();
    }
  
  // Takes a player id as an argument, which is a bit redundant.  
  public function think( e : Event ) : void
    {
    var i : int;
    var j : int;
    
    var targetChar : String;
    if ( initials.length < name.length+1 )
      {
      targetChar = name.charAt(initials.length-1);
      if ( targetChar == " " )
        targetChar = "SPC";
      }
    else // we're done here
      {
      if ( !expired )
        {
        panel.enterSelection("DONE");
        expired = true;
        }
      this.stop();
      return;
      }
    
    var searchComplete : Boolean = false;
    var targetX : int = 0;
    var targetY : int = 0;
    for ( i = 0; i < board.length; i++ )
      {
      var row : Array = board[i];
      for ( j = 0; j < row.length; j++ )
        {
        if ( row[j] == targetChar )
          {
          searchComplete = true;
          targetX = j;
          targetY = i;
          }
        }
      }
    
    var dx : int = x - targetX;
    var dy : int = y - targetY;
    
    if ( Math.abs(dx) > Math.abs(dy) )
      {
      if ( dx > 0 )
        x = xPress(-1,playerID);
      else if ( dx < 0 )
        x = xPress(1,playerID);
      else
        panel.enterSelection( targetChar );
      }
    else
      {
      if ( dy > 0 )
        y = yPress(-1,playerID);
      else if ( dy < 0 )
        y = yPress(1,playerID);
      else
        panel.enterSelection( targetChar );
      }
    } // function think()
  } // class HighScoresAI
} // packagepackage highscores
{

import flash.display.Sprite;
import flash.display.Graphics;
import flash.text.TextField;
import flash.text.TextFormat;

import com.pixeldroid.r_c4d3.controls.ControlEvent;
import com.pixeldroid.r_c4d3.controls.fourplayer.PlayerControlListener;
import com.pixeldroid.r_c4d3.scoring.RemoteHighScores;

import highscores.HighScores;
import highscores.HighScoresPanel;
import highscores.HighScoresAI;
import highscores.HighScoresMovementTimer;
import FPSDisplay;
import GameClock;

import Assets;

public class HighScoresEntryScreen extends PlayerControlListener // which extends Sprite
  {
  public var expired : Boolean;
  
  private var graphicsLayer : Sprite;
  private var reticleSprites : Array;
  //private var controls : HighScoresControls;
  
  private var panels : Array;
  private var initialsFields : Array;
  
  private var xCoords : Array;
  private var yCoords : Array;
  private var xTimers : Array;
  private var yTimers : Array;
  
  private var fpsDisplay : FPSDisplay;
  private var gameClock : GameClock;
  
  private const poolX : uint = 75;
  private const poolY : uint = 225;
  private const xSpacing : uint = 68;
  private const ySpacing : uint = 68;
  private const reticleRadius : uint = 26;
  
  private static const keypad : Array = 
  [ ["A","B","C","D","E","F","G","H","I"],
    ["J","K","L","M","N","O","P","Q","R"],
    ["S","T","U","V","W","X","Y","Z","0"],
    ["1","2","3","4","5","6","7","8","9"],
    [".","$","?","!","%","SPC","DEL","CLR","DONE"]
  ];
  
  private static var letters : Array; // Array of arrays of TextFields
  public var winningScores : Array; // Array of ScoreLisings
  private var lastTime : Number;
  private var debouncer : Debouncer;
  
  public function HighScoresEntryScreen(shipSpecs:Array)
    {
    var i : int;
    var j : int;
    
    fpsDisplay = new FPSDisplay();
    gameClock = new GameClock(120,400,5,0.61,0.61);
    debouncer = new Debouncer();
    
    graphicsLayer = new Sprite();
    reticleSprites = new Array(4);
    for ( i = 0; i < 4; i++ )
      reticleSprites[i] = new Sprite();
    
    var date : Date = new Date();
    lastTime = date.getTime();
    
    // use this code if starting in the high score entry state (for debug purposes)
    /*for ( i = 0; i < 4; i++ )
      shipSpecs[i].careerEarnings = (3-i) * 1001;
    
    shipSpecs[1].teamCode = ShipSpec.BLUE_TEAM;
    shipSpecs[1].isCPUControlled = true;
    
    shipSpecs[0].isCPUControlled = false;
    shipSpecs[2].isCPUControlled = false;
    shipSpecs[3].isCPUControlled = false;
    */
    
    var teamScores : Array = new Array(4);  // how much money did this team make, combined?    
    var scoreListing : ScoreListing;
    
    // Sum ship earnings into team earnings.
    for (i = 0; i < 4; i++)
      {
      for ( j = 0; j < i; j++ )
        if ( shipSpecs[i].teamCode == shipSpecs[j].teamCode )
          {
          // make sure the scoreListings are identical.
          scoreListing = teamScores[j];
          scoreListing.teamSize++;
          }
      
      if ( scoreListing == null )
        {
        scoreListing = new ScoreListing;
        scoreListing.playerIDs = new Array(0);
        scoreListing.score = 0;
        scoreListing.teamSize = 1;
        }
      
      scoreListing.playerIDs.push( i );
      scoreListing.score += shipSpecs[i].careerEarnings;
      teamScores[i] = scoreListing;
      trace( "scoreListing.initials = "+scoreListing.initials );
      scoreListing = null;
      }
    
    var sortedScores : Array = new Array(0);
    winningScores = new Array(0);
    var winners : Array = new Array(4);
    for ( i = 0; i < 4; i++ )
      winners[i] = false;
    
    for ( i = 0; i < 4; i++ )
      {
      // skip over duplicates... the elements of sortedScores are unique
      var cont : Boolean = false;
      for ( j = 0; j < i; j++ )
        if ( teamScores[i] == teamScores[j] )
          cont = true;
      if ( cont )
        continue;
      
      // check for validity, and if valid add it to the sortedScores list
      // Only potential candidates for high score'edness are permitted in sortedScores.  
      if ( teamScores[i].score > -1 && teamScores[i].teamSize > 0 )
        sortedScores.push( teamScores[i] );
      }
    
    HighScores.sortScores(sortedScores);
    
    // Now sortedScores[0] is the highest score, [1] the second highest, and so on.
    // Start with the highest score, see if it makes it into the high scores.  
    // If it does, leave it there and try the next.
    // Otherwise, leave the original array alone and try the next.  
    // This handles the case where there are multiple high scoring people
    //   and the lower scoring person gets checked first and makes it,
    //   even though they shouldn't when the higher scores are taken into
    //   consideration.  
    for ( i = 0; i < sortedScores.length; i++ )
      {
      scoreListing = sortedScores[i];
      var originalScores : Array = HighScores.scoreArrayArray[scoreListing.teamSize-1];
      var potentialScores : Array = new Array(originalScores.length);
      for ( j = 0; j < originalScores.length; j++ )
        potentialScores[j] = originalScores[j];
      potentialScores.push( scoreListing );
      HighScores.sortScores(potentialScores);
      potentialScores.length--;
      if ( HighScores.cmpScoreArrays( potentialScores, originalScores ) )
        continue;
      
      HighScores.scoreArrayArray[scoreListing.teamSize-1] = potentialScores;
      
      for ( j = 0; j < scoreListing.playerIDs.length; j++ )
        {
        winners[scoreListing.playerIDs[j]] = true;
        winningScores.push(scoreListing);
        }
      }
    
    // storing scores is done, now for panels
    panels = new Array(4);
    for ( i = 0; i < 4; i++ )
      panels[i] = new HighScoresPanel( shipSpecs[i], teamScores[i], winners[i] );
    
    /*
    panels[0].shipSpec.teamCode = ShipSpec.YELLOW_TEAM;
    panels[1].shipSpec.teamCode = ShipSpec.GREEN_TEAM;
    panels[2].shipSpec.teamCode = ShipSpec.RED_TEAM;
    panels[3].shipSpec.teamCode = ShipSpec.BLUE_TEAM;
    
    panels[3].shipSpec.isCPUControlled = true;
    */
    
    xCoords = new Array(4);
    yCoords = new Array(4);
    
    // far left
    panels[2].x = 0;
    
    // left
    panels[0].x = 200;
    
    // right
    panels[1].x = 400;
    
    // far right
    panels[3].x = 600;
    
    // lower left
    xCoords[0] = 0;
    yCoords[0] = keypad.length - 1;
    
    // lower right
    xCoords[1] = keypad[keypad.length - 1].length - 1;
    yCoords[1] = keypad.length - 1;
    
    // upper left
    xCoords[2] = 0;
    yCoords[2] = 0;
    
    // upper right
    xCoords[3] = keypad[0].length - 1;
    yCoords[3] = 0;
    
    xTimers = new Array(4);
    yTimers = new Array(4);
    for ( i = 0; i < 4; i++ )
      {
      xTimers[i] = new HighScoresMovementTimer();
      yTimers[i] = new HighScoresMovementTimer();
      }
    
    //addEventListener(Event.ENTER_FRAME, onEnterFrame);
    
    // Let's make some robot names.  
    var aiNames : Array = new Array(4);
    for ( i = 0; i < 4; i++ )
      {
      var foundUnique : Boolean = false;
      
      while ( !foundUnique )
        {
        aiNames[i] = generateRobotName();
        
        if ( i > 0 )
          {
          for ( j = 0; j < i; j++ )
            {
            trace( "My name is "+aiNames[i] );
            trace( "His name is "+aiNames[j] );
            if ( aiNames[i] != aiNames[j] )
              {
              foundUnique = true;
              break;
              }
            }
          }
        else
          foundUnique = true;
        
        } // while ( !foundUnique )
      }
    
    // Now that we have some playthrough-unique AI names, have the AI enter them.  
    for ( i = 0; i < 4; i++ )
      {
      if ( panels[i].shipSpec.isCPUControlled )
        {
        if ( panels[i].highScore )
          var ai : HighScoresAI = new HighScoresAI( aiNames[i], i, xCoords[i], yCoords[i],
                                                  keypad, panels[i], xPress, yPress );
        else
          panels[i].enterSelection("DONE");
        }
      }
    
    draw();
    }
  
  // This assumes 8 character names
  public static function generateRobotName() : String
    {
    var char1 : String;
    var char2 : String;
    var char3 : String;
    var char4 : String;
    
    const max : int = 6;
    var random : int = Math.random() * max;
    if ( random == max )
      random = 0;
    
    switch( random )
      {
      case 0:
        char1 = "R";
        char2 = "A";
        char3 = "C";
        char4 = randomDigit();
        break;
      case 1:
        char1 = "C";
        char2 = randomDigit();
        char3 = "J";
        char4 = randomDigit();
        break;
      case 2:
        char1 = "D";
        char2 = randomDigit();
        char3 = "G";
        char4 = randomDigit();
        break;
      case 3:
        char1 = "H";
        char2 = randomDigit();
        char3 = "C";
        char4 = randomDigit();
        break;
      case 4:
        char1 = "J";
        char2 = randomDigit();
        char3 = "P";
        char4 = randomDigit();
        break;
      case 5:
        char1 = "J";
        char2 = randomDigit();
        char3 = "L";
        char4 = randomDigit();
        break;
      }
    
    return "CPU "+char1+char2+char3+char4;
    }
  
  private static function randomDigit() : String
    {
    var integer : int = Math.random() * 10;
    if ( integer == 10 ) // extremely small edge case
      integer = 0;
    return ""+integer;
    }
  
  private static var phi : Number = 0;
  
  public function update() : void
    {
    var i : int;
    var j : int;
    
    fpsDisplay.update();    
    var deltaT : Number = 25.0 / fpsDisplay.FPS;
    gameClock.update(deltaT);
    
    if ( gameClock.clockIsZero() )
      for ( i = 0; i < 4; i++ )
        panels[i].done = true; // force everyone to be done
    
    var graphics : Graphics = graphicsLayer.graphics;
    graphics.clear();
    
    var date : Date = new Date();
    var time : Number = date.getTime();
    var timeDelta : Number = time - lastTime;
    lastTime = time;
    
    // update any changes that may have happened in the panels
    for ( i = 0; i < 4; i++ )
      panels[i].update();
    
    // draw selectors
    for ( i = 0; i < 4; i++ )
      {
      // if he/she/it is a loser, don't draw the reticle
      if ( !panels[i].highScore )
        continue;
      //
      
      var spec : ShipSpec = panels[i].shipSpec;
      
      reticleSprites[i].x = gridToScreenX(xCoords[i])+35;
      reticleSprites[i].y = gridToScreenY(yCoords[i])+13;
      
      var omega : Number = 0.05 + 0.05 * (spec.reticleLevel/10);
      
      // Spin
      phi += Math.PI*timeDelta/2400;
      
      ReticleGraphics.draw (panels[i].shipSpec, reticleSprites[i], phi, reticleRadius, 0, false);
      }
    
    // check to see if everyone is a loser, if that's the case then everyone has to press done to get by.  
    // This is done to make sure everyone gets to see that they are, indeed, losers.  
    var allLosers : Boolean = true;
    for ( i = 0; i < 4; i++ )
      if ( panels[i].highScore )
        allLosers = false;
    
    // check to see if we are done
    var done : Boolean = true;
    if ( allLosers )
      {
      for ( i = 0; i < 4; i++ )
        if ( !panels[i].done )
          done = false;
      }
    else
      {
      for ( i = 0; i < 4; i++ )
        // the && highScore makes it so people who didn't win don't have to press done
        if ( !panels[i].done && panels[i].highScore ) 
          done = false;
      }
    
    expired = done;
    
    
    if ( expired )
      expire();
    }
  
  public function draw() : void
    {
    // first let's draw the top 4 boxes.  This code should reduce when some artwork comes in.
    initialsFields = new Array(4);
    
    Screen.background.addChild( new Assets.HighScoresBackground() );
    
    var i : int;
    
    for ( i = 0; i < 4; i++ )
      {
      Screen.midground.addChild( panels[i] );
      Screen.hud.addChild( reticleSprites[i] );
      }
    
    // now draw the field of letters
    var x : int;
    var y : int;
    var format : TextFormat = new TextFormat();
    format.font = "text";
    format.align = "center";
    format.bold = true;
    format.color = 0xffffff;
    format.size = 24;
    var specialFormat : TextFormat = new TextFormat();
    specialFormat.font = "text";
    specialFormat.align = "center";
    specialFormat.bold = true;
    specialFormat.color = 0xffffff;
    specialFormat.size = 17;
    letters = new Array(keypad.length);
    for ( y = 0; y < keypad.length; y++ )
      {
      letters[y] = new Array(keypad[y].length);
      for ( x = 0; x < keypad[y].length; x++ )
        {
        var tf : TextField = new TextField();
        tf.text = keypad[y][x];
        tf.embedFonts = true;
        tf.x = poolX + x * xSpacing;
        tf.y = poolY + y * ySpacing;
        tf.width = xSpacing;
        tf.height = ySpacing;
        if ( tf.text == "DONE" || tf.text == "SPC" || tf.text == "DEL" || tf.text == "CLR" )
          {
          tf.y += 4;
          tf.setTextFormat(specialFormat);
          }
        else
          tf.setTextFormat(format);
        Screen.midground.addChild(tf);
        letters[y][x] = tf;
        }
      }
    
    Screen.foreground.addChild( graphicsLayer );
    } // function draw()
  
  private function gridToScreenX( input : int ) : int
    {
    return poolX + input * xSpacing;
    }
  
  private function gridToScreenY( input : int ) : int
    {
    return poolY + input * ySpacing;
    }
  
  // use the below two lines to make the attract loop go faster.
  //private var pindex : int = 0;
  //protected override function Xr(e:ControlEvent) : void { panels[pindex % 4].donePress(); pindex++; }
  protected override function Xr(e:ControlEvent) : void { panels[e.playerIndex].donePress(); }
  protected override function Br(e:ControlEvent) : void { panels[e.playerIndex].deletePress(); }
  protected override function Cr(e:ControlEvent) : void { panels[e.playerIndex].deletePress(); }
  protected override function Ar(e:ControlEvent) : void { enterSelection( e.playerIndex ); }
  
  protected override function Rp(e:ControlEvent):void { trace( "Rp"+e.playerIndex ); xPlayerPress(  1, e.playerIndex ); }
  protected override function Rr(e:ControlEvent):void { trace( "Rr"+e.playerIndex ); xRelease    (  1, e.playerIndex ); }
  protected override function Up(e:ControlEvent):void { trace( "Up"+e.playerIndex ); yPlayerPress( -1, e.playerIndex ); }
  protected override function Ur(e:ControlEvent):void { trace( "Ur"+e.playerIndex ); yRelease    ( -1, e.playerIndex ); }
  protected override function Lp(e:ControlEvent):void { trace( "Lp"+e.playerIndex ); xPlayerPress( -1, e.playerIndex ); }
  protected override function Lr(e:ControlEvent):void { trace( "Lr"+e.playerIndex ); xRelease    ( -1, e.playerIndex ); }
  protected override function Dp(e:ControlEvent):void { trace( "Dp"+e.playerIndex ); yPlayerPress(  1, e.playerIndex ); }
  protected override function Dr(e:ControlEvent):void { trace( "Dr"+e.playerIndex ); yRelease    (  1, e.playerIndex ); }
  
  private function enterSelection( player : uint ) : void
    {
    panels[player].enterSelection(keypad[yCoords[player]][xCoords[player]]);
    }
  
  private function xPlayerPress( direction : int, player : uint ) : void
    {
    if(!debouncer.debounced())
      return;
    else
      debouncer.setLastEventTime();
    
    if ( !panels[player].shipSpec.isCPUControlled )
      xPress( direction, player );
    }
  
  // returns the resultant x position
  private function xPress( direction : int, player : uint ) : int
    {
    if ( direction > 0 )
      incrementXCoord(player);
    else
      decrementXCoord(player);
    
    if ( !panels[player].shipSpec.isCPUControlled )
      {
      if ( direction > 0 )
        xTimers[player].callback = incrementXCoord;
      else
        xTimers[player].callback = decrementXCoord;
        
      xTimers[player].player = player;
      xTimers[player].start();
      }
    
    panels[player].onSelectionChange(keypad[yCoords[player]][xCoords[player]]);
    
    return xCoords[player];
    }
  
  private function yPlayerPress( direction : int, player : uint ) : void
    {
    if(!debouncer.debounced())
      return;
    else
      debouncer.setLastEventTime();
    
    if ( !panels[player].shipSpec.isCPUControlled )
      yPress( direction, player );
    }
  
  // returns the resultant y position
  private function yPress( direction : int, player : uint ) : int
    {
    if ( direction > 0 )
      incrementYCoord(player);
    else
      decrementYCoord(player);
    
    if ( !panels[player].shipSpec.isCPUControlled )
      {
      if ( direction > 0 )
        yTimers[player].callback = incrementYCoord;
      else
        yTimers[player].callback = decrementYCoord;
      
      yTimers[player].player = player;
      yTimers[player].start();
      }
    
    panels[player].onSelectionChange(keypad[yCoords[player]][xCoords[player]]);
    
    return yCoords[player];
    }
  
  private function xRelease( direction : int, player : uint ) : void
    {
    if ( !panels[player].shipSpec.isCPUControlled )
      xTimers[player].stop();
    }
  
  private function yRelease( direction : int, player : uint ) : void
    {
    if ( !panels[player].shipSpec.isCPUControlled )
      yTimers[player].stop();
    }
  
  private function incrementXCoord( player : uint ) : void
    {
    xCoords[player]++;
    
    if ( xCoords[player] >= keypad[yCoords[player]].length )
      xCoords[player] = 0;
    }
  
  private function decrementXCoord( player : uint ) : void
    {
    xCoords[player]--;
    
    if ( xCoords[player] < 0 )
      xCoords[player] = keypad[yCoords[player]].length - 1;
    }
  
  private function incrementYCoord( player : uint ) : void
    {
    yCoords[player]++;
    
    if ( yCoords[player] >= keypad.length )
      yCoords[player] = 0;
    }
  
  private function decrementYCoord( player : uint ) : void
    {
    yCoords[player]--;
    
    if ( yCoords[player] < 0 )
      yCoords[player] = keypad.length - 1;
    }
  
  public function expire() : void
    {
    var i : int;
    var j : int;
    
    expired = true;
    
    // Make sure the initials get entered correctly.  
    for ( i = 0; i < winningScores.length; i++ )
      {
      var hsp : HighScoresPanel = panels[ winningScores[i].playerIDs[0] ];
      winningScores[i].initials = hsp.initials.slice( 0, hsp.initials.length - 1 );
      for ( j = 1; j < winningScores[i].playerIDs.length; j++ )
        {
        hsp = panels[ winningScores[i].playerIDs[j] ];
        winningScores[i].initials += ", "+hsp.initials.slice( 0, hsp.initials.length - 1 );
        }
      }
    
  
    // Now modify the remote server's data.  
    for ( i = 0; i < 4; i++ )
      {
      var arr : Array = HighScores.scoreArrayArray[i];
      
      for ( j = 0; j < HighScores.numScoresStored; j++ )
        HighScores.RMH[i].insert( arr[j].score, arr[j].initials );
      
      HighScores.RMH[i].store();
      }
    
    // release the input control
    disconnect();
    
    // free screen resources  
    gameClock.expire();
    Screen.reset();
    }
  
  } // class HighScores

}package highscores
{

import flash.utils.Timer;
import flash.events.*;

public class HighScoresMovementTimer extends Timer
  {
  
  public static const movementDelay : Number = 250; // 500 milliseconds between movements
  
  public var player : uint;
  public var callback : Function;
  
  public function HighScoresMovementTimer()
    {
    super(movementDelay);
    addEventListener(TimerEvent.TIMER, onTick);
    }
  
  private function onTick(event:Event) : void
    {
    callback( player );
    }
  
  } // class HighScoresMovementTimer

}package highscores
{

import com.pixeldroid.data.DataEvent;
import com.pixeldroid.r_c4d3.scoring.ScoreEvent;
import com.pixeldroid.r_c4d3.scoring.RemoteHighScores;

import flash.text.*;
import flash.display.*;
import flash.events.Event;

import Firework;
import Screen;
import highscores.ScoreListing;

public class HighScores extends Sprite
  {
  public static const numScoresStored : uint = 10;
  private static const scoreServerURL : String = "http://accad.osu.edu/arcade/scores/";
  
  private static const titleY : uint = 20;
  private static const teamTypeY : uint = 60;
  private static const column1X : uint = 250; // ranking column
  private static const column2X : uint = 325; // player initials column
  private static const column3X : uint = 500; // score column
  private static const columnsY : uint = 110; // How far down on the screen the columns start.  
                                              //   this includes column titles.  
  private static const initialsSize : uint = 110; // approximately how many pixels each initial/name entry may take
                                                  // This is only a fraction of what a comma-delimited team entry will be.  
  private static const columnYSpacing : uint = 40;
  
  private static const duration : Number = 5; // Time, in seconds, each of the 4 high scores screens gets shown.  
  
  private static const defaultScoresInitials : Array =
    [
    "----------",
    "---------",
    "--------",
    "-------",
    "------",
    
    "-----",
    "----",
    "---",
    "--",
    "-"
    ];
  
  private static const defaultScoresValues : Array = 
    [
    0,
    0,
    0,
    0,
    0,
    
    0,
    0,
    0,
    0,
    0
    ];
  
  // array for holding all of the different types of scores
  // scoreArrayArray[0] = 1 player high scores
  // scoreArrayArray[1] = 2 player high scores
  // scoreArrayArray[2] = 3 player high scores
  // scoreArrayArray[3] = 4 player high scores
  public static var scoreArrayArray : Array; 
  
  // Array of RemoteHighScores objects.
  public static var RMH : Array;
  
  // this array should be sorted by scores.
  // sessionScores[0] should be the highest score, and sessionScores[max] should be the lowest score
  // If a score is not entered, it shall be inserted as a -1.  
  //   -1 is considered to be less than a score of 0.  
  public var scores : Array; // array of ScoreListings
  
  public var expired : Boolean;
  private var startTime : Number; // Time, in millisecs, when this highscores started.
  private var teamType : uint; // 1, 2, 3, or 4.  Specifies how many players were involved 
                               //  in the teams on the scores currently being shown.  
  
  private var fireworksLayer : Sprite;
  private var textLayer : Sprite;
  
  private var fireworks : Array;
  private var fireworkCooldown : Number;
  private var fpsDisplay:FPSDisplay;
  
  private static function getGameID( index : uint ) : String
    {
    switch( index )
      {
      case 0: return "au2007SpiceHunter1";
      case 1: return "au2007SpiceHunter2";
      case 2: return "au2007SpiceHunter3";
      case 3: return "au2007SpiceHunter4";
      }
    
    return "";
    }
  
  // call this when the game starts
  // right now all this does is generate randomness, it should eventually load up real scores
  public static function init() : void
    {
    scoreArrayArray = new Array(4);
    RMH = new Array(4);
    var i : int;
    for ( i = 0; i < 4; i++ )
      initScoreArray(i);
    }
  
  // this will probably end up with another arg or two, to tell pdroid which scores to load
  private static function initScoreArray(index:int) : void
    {
    generateStartingScores(index+1);
    trace( "Initializing Score Array "+index );
    RMH[index] = new RemoteHighScores(getGameID(index), numScoresStored, scoreServerURL);
    RMH[index].addEventListener(ScoreEvent.LOAD,getLoadListener(index));
    RMH[index].addEventListener(DataEvent.ERROR,onDataError);
    RMH[index].load();
    }
  
  private static function getLoadListener( index : uint ) : Function
    {
    switch( index )
      {
      case 0: return onLoad1;
      case 1: return onLoad2;
      case 2: return onLoad3;
      case 3: return onLoad4;
      }
    trace("no load listener matching index " +index);
    return null;
    }
  
  private static function onLoad1(e:ScoreEvent) : void { trace("onLoad1"); onLoad(e,0); }
  private static function onLoad2(e:ScoreEvent) : void { trace("onLoad2"); onLoad(e,1); }
  private static function onLoad3(e:ScoreEvent) : void { trace("onLoad3"); onLoad(e,2); }
  private static function onLoad4(e:ScoreEvent) : void { trace("onLoad4"); onLoad(e,3); }
  
  private static function onLoad(e:ScoreEvent,index:uint) : void
    {
    var i : int;
    
    if ( e.success )
      {
      var m_RMH : RemoteHighScores = RMH[index];
      //m_RMH.reset();
      
      if ( m_RMH.length == numScoresStored )
        {
        
        // check for erranious null initials
        for ( i = 0; i < numScoresStored; i++ )
          {
        trace( "m_RMH.getInitials(i) = "+m_RMH.getInitials(i) );
          if ( m_RMH.getInitials(i) == null )
            return;
          }
        
        // it was successful, so load em up
        var array : Array = new Array(numScoresStored);
        
        for ( i = 0; i < numScoresStored; i++ )
          {
          array[i] = new ScoreListing();
          array[i].score = m_RMH.getScore(i);
          array[i].initials = m_RMH.getInitials(i);
          scoreArrayArray[index] = array;
          }
        }
      }
    
    }
  
  private static function onDataError(e:DataEvent) : void
    {
    trace( e.message );
    }
  
  private static function generateStartingScores(teamSize:uint) : void
    {
    var i : int;
    var j : int;
    var array : Array = new Array(numScoresStored);
    
    // generate stuff for this session, and let HighScoresEntry handle the writing later.  
    /*for ( i = 0; i < numScoresStored; i++ )
      {
      var integer : uint = Math.random() * 1000;
      array[i] = new ScoreListing();
      array[i].score = integer + 1000;
      array[i].initials = generateRobotName();
      for ( j = 1; j < teamSize; j++ )
        array[i].initials += ", "+generateRobotName();
      }
    
    sortScores( array );*/
    
    for ( i = 0; i < numScoresStored; i++ )
      {
      array[i] = new ScoreListing();
      array[i].score = defaultScoresValues[i];
      array[i].initials = defaultScoresInitials[i];
      }
    
    scoreArrayArray[teamSize-1] = array;
    }
  
  public static function sortScores( scores : Array ) : void
    {
    if ( scores.length < 2 )
      return;
    
    // simple bubble sort algo
    var i : int;
    var sorted : Boolean = false;
    var lastListing : ScoreListing;
    var currentListing : ScoreListing;
    
    while ( !sorted )
      {
      sorted = true;
      lastListing = scores[0];
      
      for ( i = 1; i < scores.length; i++ )
        {
        currentListing = scores[i];
        if ( lastListing.score < currentListing.score )
          {
          sorted = false;
          
          scores[i] = lastListing;
          scores[i-1] = currentListing;
          }
        lastListing = currentListing;
        }
      }
    }
  
  // returns true if the contents of the arrays are the same
  // false if they are not
  public static function cmpScoreArrays( scores1 : Array, scores2 : Array ) : Boolean
    {
    var i : int;
    
    if ( scores1.length != scores2.length )
      return false;
    
    for ( i = 0; i < scores1.length; i++ )
      if ( scores1[i] != scores2[i] )
        return false;
    
    return true;
    }
  
  public function HighScores()
    {
    teamType = 1;
    scores = scoreArrayArray[teamType-1];
    
    var date : Date = new Date();
    startTime = date.getTime();
    expired = false;
    
    fireworks = new Array;
    fireworkCooldown = 0;
    fpsDisplay = new FPSDisplay();
    
    Screen.root.addChild(this);
    
    fireworksLayer = new Sprite();
    textLayer = new Sprite();
    
    addChild( new Assets.Background );
    addChild( fireworksLayer );
    addChild( textLayer );
    
    //Screen.background.addChild(new Assets.Background);
    
    showScores();
    }
  
  public function update() : void
    {
    fpsDisplay.update();
    var deltaT : Number = 25.0 / fpsDisplay.FPS;
    
    fireworkCooldown -= deltaT;
    if (fireworkCooldown < 0)
      // Spawn a new firework.
      {
      var f:Firework = new Firework(fireworksLayer);
      f.rx = Math.random()*800;
      f.ry = Math.random()*600;      	
      f.radius = Math.random()*300 + 100;
      fireworks.push(f);      
      fireworkCooldown = Math.random()*15 + 5;      
      Utility.playSound (new Assets.AstExplode() );
      }
    // Update fireworks.
    var loop1 : Number;
    for (loop1 = 0; loop1 < fireworks.length; loop1++)
      fireworks[loop1].update(deltaT);
    
    // Remove expired fireworks.
    loop1 = 0;
    while (loop1 < fireworks.length)
      if (fireworks[loop1].isExpired)
        {
        fireworks[loop1] = fireworks[fireworks.length-1];
        fireworks.pop();
        }
      else
        loop1++;
    
    // check to see if we are done.
    var date : Date = new Date();
    if ( startTime + (duration * 4000) < date.getTime() )
      expire();
    else if ( startTime + (duration * 3000) < date.getTime() )
      {
      teamType = 4;
      showScores();
      }
    else if ( startTime + (duration * 2000) < date.getTime() )
      {
      teamType = 3;
      showScores();
      }
    else if ( startTime + (duration * 1000) < date.getTime() )
      {
      teamType = 2;
      showScores();
      }
    }
  
  public function showScores() : void
    {
    // first, some cleanup and initialization
    var i : int;
    var j : int;
    
    while ( textLayer.numChildren > 0 )
      textLayer.removeChildAt(0);
    
    scores = scoreArrayArray[teamType-1];
    
    //Text Fields
    var x1 : int = column1X - initialsSize * (teamType-1) / 2;
    var x2 : int = column2X - initialsSize * (teamType-1) / 2;
    var x3 : int = column3X + initialsSize * (teamType-1) / 2;
    
    var tformat : TextFormat = new TextFormat();
    tformat.font = "title";
    tformat.size = 32;
    tformat.color = 0xffffff;
    tformat.bold = true;
    tformat.align = "center";
    
    placeText( 0, titleY, "High Scores", tformat, 800 );
    
    tformat.size = 24;
    
    if ( teamType < 2 )
      placeText( 0, teamTypeY, teamType+" Player Scores", tformat, 800 );
    else
      placeText( 0, teamTypeY, teamType+" Player Team Scores", tformat, 800 );
      
    tformat.font = "text";
    tformat.size = 18;
    tformat.align = "left";
    
    placeText( x1, columnsY, "Rank", tformat );
    placeText( x2, columnsY, "Initials", tformat );
    placeText( x3, columnsY, "Score", tformat );
    
    //var halfScores : int = numScoresStored / 2;
    var y : int;
    
    for ( i = 0; i < numScoresStored; i++ )
      {
      y = columnsY + (i+1) * columnYSpacing;
      
      placeText( x1, y, ""+(i+1), tformat ); // rank
      placeText( x2, y, scores[i].initials, tformat, initialsSize * teamType + 10 );
      placeText( x3, y, ""+scores[i].score, tformat );
      }
    
    /*
    placeText( column1X+rightColumnsX, columnsY, "Rank", tformat );
    placeText( column2X+rightColumnsX, columnsY, "Initials", tformat );
    placeText( column3X+rightColumnsX, columnsY, "Score", tformat );
    
    for ( j = halfScores; j < numScoresStored; j++ )
      {
      i = j - halfScores;
      y = columnsY + (i+1) * columnYSpacing;
      
      placeText( column1X+rightColumnsX, y, ""+(j+1), tformat ); // rank
      placeText( column2X+rightColumnsX, y, scores[j].initials, tformat );
      placeText( column3X+rightColumnsX, y, ""+scores[j].score, tformat );
      }
    */
    }
  
  private function placeText( x : int, y : int, text : String, 
                              format : TextFormat = null, width : int = -1, 
                              sprite : Sprite = null ) : TextField
    {
    var tf : TextField = new TextField();
    tf.embedFonts = true;
    tf.x = x;
    tf.y = y;
    if ( width >= 0 )
      tf.width = width;
    tf.text = text;
    if ( format != null )
      tf.setTextFormat( format );
    if ( sprite == null )
      sprite = textLayer;
    sprite.addChild( tf );
    return tf;
    }
  
  public function expire() : void
    {
    //Screen.root.removeEventListener(Event.ENTER_FRAME, onEnterFrame);
    
    trace( "Expiring at team "+teamType );
    
    var i : int;
    
    fpsDisplay.expire();
    
    for ( i = 0; i < fireworks.length; i++ )
      fireworks[i].expire();
    
    expired = true;
    
    while ( textLayer.numChildren > 0 )
      textLayer.removeChildAt(0);
    
    removeChild( textLayer );
    removeChild( fireworksLayer );
    
    Screen.reset();
    }
  }

}